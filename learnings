#COMPARISON OPERATORS
'==' equals to operator, returns boolean value
eg:  null == undefined //polymorphism of ==
     true
exception:  NaN==NaN
            false
//converts int->string but not vice-versa
eg:  10=="10"
     true
'===' checks that values as well as data types are same,prevents polymorphism of ==
eg: null === undefined
    false
'!=' checks if lhs not equal to rhs
eg: 10!="10"
    false
'!==' prevents polymorphism of !=
eg:  10!=="10"
     true
'>' , '>=' , '<' , '<=' ,

#IF AND CONDITIONAL OPERATORS
script1.js
var carsLeft=1,carsRight=0,greenMan='no';

if(greenMan==="yes")
{
    console.log('cross the road');
}
else if(carsLeft==0 && carsRight==0)
{
    console.log("all clear!cross the road");
}
else
{
    console.log("stay where you are!");
}

#FOR AND FOR IN LOOP(script2.js)

var classReg=["lawrence","john","jeff"];

console.log(classReg[0]);
console.log(classReg[1]);
console.log(classReg[2]);

//for loop
for(var i=0;i<classReg.length;i++)
    console.log(classReg[i]);

//for in loop
for(var i in classReg)
    console.log(classReg[i]);

script2.js:3 lawrence
script2.js:4 john
script2.js:5 jeff

script2.js:9 lawrence
script2.js:9 john
script2.js:9 jeff

script2.js:13 lawrence
script2.js:13 john
script2.js:13 jeff

#LET(script3)
new way of declaring variables other than var, scope remains within parenthesis, no global scope unlike var.
var only follows scope in case of function whereas let follows scope always
if(true)
{
    var symbolName="value reference in memory";
    let letSym="scoped value";
    const symName="const value in memory";
}
output:   symbolName
          'value reference in memory'
          letSym
          VM64:1 Uncaught ReferenceError: letSym is not defined
              at <anonymous>:1:1
          (anonymous) @ VM64:1Understand this error
          symName
          VM81:1 Uncaught ReferenceError: symName is not defined
              at <anonymous>:1:1
          (anonymous) @ VM81:1Understand this error

for(var i=0;i<5;i++)
{
    var symbolName="value reference in memory";
    let letSym="scoped value";
    const symName="const value in memory";
}
output:   i
          5
          symbolName
          'value reference in memory'
          letSym
          VM118:1 Uncaught ReferenceError: letSym is not defined
              at <anonymous>:1:1
          (anonymous) @ VM118:1Understand this error
          symName
          VM136:1 Uncaught ReferenceError: symName is not defined
              at <anonymous>:1:1

for(let i=0;i<5;i++)
{
    var symbolName="value reference in memory";
    let letSym="scoped value";
    const symName="const value in memory";
}
output:   i
          VM145:1 Uncaught ReferenceError: i is not defined
          at <anonymous>:1:1
         (anonymous) @ VM145:1Understand this error
          symbolName
          'value reference in memory'
          letSym
          VM175:1 Uncaught ReferenceError: letSym is not defined
          at <anonymous>:1:1
          (anonymous) @ VM175:1Understand this error
          symName
          VM192:1 Uncaught ReferenceError: symName is not defined
          at <anonymous>:1:1

function check()
{
    var symbolName="value reference in memory";
    let letSym="scoped value";
    const symName="const value in memory";
}
output:symbolName
     VM297:1 Uncaught ReferenceError: symbolName is not defined
         at <anonymous>:1:1
     (anonymous) @ VM297:1Understand this error
     letSym
     VM315:1 Uncaught ReferenceError: letSym is not defined
         at <anonymous>:1:1
     (anonymous) @ VM315:1Understand this error
     symName
     VM334:1 Uncaught ReferenceError: symName is not defined
         at <anonymous>:1:1
